#include <iostream>
#include "cmath"

struct point{
     int x;
     int y;

    point(int x, int y): x(x), y(y) {
        //Внутри тела этой функции новый экземпляр point будет уже создан. Поэтому константный член не может быть задан внутри.
        //Все члены нового объекта создаются между объявления и реализацией конструктора.
        //Не константные члены могут быть инициализированы значениями, после, внутри тела конструктора.
        //Но константные же, поскольку после создания коих нельзя изменять, нужно инициализировать сразу при создании (скрытой декларации)
        std::cout << "base constructor" << std::endl;
    }

    point(const point& other): x(other.x), y(other.y){
        //Конструктор копирования используется для создания нового экземпляра класса (нового участка в памяти)
        //заполненного теми же данными, что и уже существующий.
        //Для вызова конструктора копирования в функцию нужно передать референсный экземпляр класса.
        //Однако при попытке передачи по значению, внутри функции создавался бы новый экземпляр с теми-же данными.
        //(Это справедливо для любой функции и даже для объектов не имеющих конструкторов копирования - будет использовать к.к. по умолчанию)
        //Т.е. нужно было бы вызывать конструктор копирования для вызова конструктора копирования.
        //Поэтому он реализуется через передачу референса по ссылке.

        //Как следствие для повышения быстродействия стоит писать функции принимающие данные по ссылкам при условии,
        //что те не будут испорчены или они могут быть испорчены без вреда для вызывающей стороны, это всегда будет предпочтительней.
        //Для предохранения от порчи, и демонстрации этого юзеру в декларации функции эти данные следует помечать спецификатором const.
        std::cout << "copy constructor" << std::endl;
    }


    void print() const{
        std::cout << "const point: x: " << point::x << " y: " << point::y << std::endl;
    }



    point operator+(const point& right){
        point new_point(point::x + right.x, point::y + right.y);//создаём новую точку с координатами суммы
        return new_point;// "Возвращаем" её
        //на самом деле эта реализация имеет 2 косяка
        //1) Возврат из функции работает так-же, как и передача в неё: создаётся новый объект типа,
        //указанного в типе функции, в который присваивается значение после return.
        //За отличием лишь в том, что при присваивании в функцию переменная имеет имя, указанное в декларации этой функции,
        //а при присваивании из функции переменная не имеет индикатора (она безымянная как lambda функции в питончике).
        //Поэтому в этой реализации вызывается конструктор для нового экземпляра point
        //вызывается конструктор копирования в эту безымянную переменную,
        //при выходе из области видимости объект с индикатором new_point удаляется вызовом деконструктора за ненадобностью.
        //Имеем в 3 раза больше ненужных вызовов.

        //2) возвращается не константный экземпляр point.
        //Т.е. на месте завершённой операции сложения будет изменяемый объект (забудем, что все его поля константы).
        //Это позволит написать что-то вроде этого: point_A + point_B = point_C; результат сложения будет переписан, а после и вовсе утерян с утечкой памяти.
        //Для более полного пояснения гуглить "Lvalue and Rvalue". В этих терминах результат сложения должен быть Rvalue.
    }

};

using namespace std;
int main(){
    point a(3,4);
    a.print();
    a.x = 5;
    a.print();

    int A = 5;
    const int B = A;
    int C = A;
    const int D = B;
    int E = B;

}