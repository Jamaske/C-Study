#include <iostream>
#include "cmath"

struct point{
     const int x;
     const int y;

    point(int x, int y): x(x), y(y) {
        //Внутри тела этой функции новый экземпляр point будет уже создан. Поэтому константный член не может быть задан внутри.
        //Все члены нового объекта создаются между объявления и реализацией конструктора.
        //Не константные члены могут быть инициализированы значениями, после, внутри тела конструктора.
        //Но константные же, поскольку после создания коих нельзя изменять, нужно инициализировать сразу при создании (скрытой декларации)
        std::cout << "base constructor" << std::endl;
    }

    point(const point& other): x(other.x), y(other.y){
        //Конструктор копирования используется для создания нового экземпляра класса (нового участка в памяти)
        //заполненного теми же данными, что и уже существующий.
        //Для вызова конструктора копирования в функцию нужно передать референсный экземпляр класса.
        //Однако при попытке передачи по значению, внутри функции создавался бы новый экземпляр с теми-же данными.
        //(Это справедливо для любой функции и даже для объектов не имеющих конструкторов копирования - будет использовать к.к. по умолчанию)
        //Т.е. нужно было бы вызывать конструктор копирования для вызова конструктора копирования.
        //Поэтому он реализуется через передачу референса по ссылке.

        //Как следствие для повышения быстродействия стоит писать функции принимающие данные по ссылкам при условии,
        //что те не будут испорчены или они могут быть испорчены без вреда для вызывающей стороны, это всегда будет предпочтительней.
        //Для предохранения от порчи, и демонстрации этого юзеру в декларации функции эти данные следует помечать спецификатором const.
        std::cout << "copy constructor" << std::endl;
    }

    ~point(){
        std::cout << "deconstrctor" << std::endl;
    }


    void print() const{
        std::cout << "const point: x: " << point::x << " y: " << point::y << std::endl;
    }




    point operator+(const point& right){
        point new_point(point::x + right.x, point::y + right.y);//создаём новую точку с координатами суммы
        return new_point;// "Возвращаем" её
        //на самом деле эта реализация имеет 2 косяка
        //1) Возврат из функции работает так-же, как и передача в неё: создаётся новый объект типа,
        //указанного в типе функции, в который присваивается значение после return.
        //За отличием лишь в том, что при присваивании в функцию переменная имеет имя, указанное в декларации этой функции,
        //а при присваивании из функции переменная не имеет идентификатор (она безымянная как lambda функции в питончике).
        //Поэтому в этой реализации вызывается конструктор для нового экземпляра point
        //вызывается конструктор копирования в эту безымянную переменную,
        //при выходе из области видимости объект с индикатором new_point удаляется вызовом деконструктора за ненадобностью.
        //Имеем в 3 раза больше ненужных вызовов.

        //2) возвращается не константный экземпляр point.
        //Т.е. на месте завершённой операции сложения будет изменяемый объект (забудем, что все его поля константы).
        //Это позволит написать что-то вроде этого: point_A + point_B = point_C; результат сложения будет переписан, а после и вовсе утерян с утечкой памяти.
        //Для более полного пояснения гуглить "Lvalue and Rvalue". В этих терминах результат сложения должен быть Rvalue.
    }

    const point& operator-(const point& right){
        point new_point(point::x - right.x, point::y - right.y);
        return new_point;
        //Попытка копирования во временную переменную при возврате по ссылке приведёт к ошибке сегментации из-за того, что внутри экземпляр point создаётся на стеке
        //После чего при выходе из области видимости у объекта с идентификатором new_point вызывается деконструктор
        //А ссылка указывает на невыделенную память
        //есть два решения 1) деконструкторы объектов из кучи не вызываются.
        //2) так как сделан следующий оператор
    }

    const point operator*(const point& right){
        return point(point::x * right.x, point::y * right.y);
        //Нужно избавиться именно от временной переменной. Не вызывать её конструктор и в последствии деконструктор.
        //При такой записи создаваемый конструктором объект сразу присваивается безымянной переменной.
        //Аналогично записи: int a = int(5);
    }

    point& operator = (const point& right){
        if(this == &right){
            return *this;
        }
        delete this;

        return *this;

    }

};



using namespace std;
int main(){
    int a[15];
    for(int i = 0; i < 15; i++){
        a[i] = i;
    }
    int* sub = &a[2*5];
    sub[1] = 42;
    for(int i = 0; i < 15; i++){
        std::cout << a[i] << ' ';
    }


}